; # Core library of Anglican utility functions.
;
; Many of these are inspired by (and shared function signatures with) functions defined
; in [clojure.core](http://clojuredocs.org/clojure_core/clojure.core). 
; When possible, the documentation here is copied verbatim from the clojure.core
; documentation.
;
; To use any of these functions in your program, simply `import` them:
;
; 	[import "http://www.robots.ox.ac.uk/~fwood/anglican/core.anglican"]
;
; More documentation and examples will be added here soon, as will additional functions.
; At the moment, the documentation consists of the allowed function signatures, and
; the function source itself.
;


; ## Reduce
; Reduce a list, using a function of two arguments, and an optional initial value
;
; (reduce f coll)
; (reduce f val coll)
;
[assume reduce (lambda arglist
    (begin
        (define func (first arglist))
        (cond
            ((= (count arglist) 2)
                (begin
                    (define list-expr (second arglist))
                    (define next-val (func (first list-expr) (second list-expr)))
                    (if (= (count list-expr) 2)
                        next-val
                        (reduce func next-val (rest (rest list-expr))))))
            ((= (count arglist) 3) 
                (begin
                    (define val (second arglist))
                    (define list-expr (second (rest arglist)))
                    (define next-val (func val (first list-expr)))
                    (if (= (count list-expr) 1)
                        next-val
                        (reduce func next-val (rest list-expr))))))))]


; ## Min
;
; Return the least of the nums
;
; (min x)
; (min x y)
; (min x y & more)
;
[assume min (lambda nums 
    (if (> (count nums) 1)
        (reduce (lambda (a b) (if (> a b) b a)) nums)
        (first nums)))]


; ## Max
;
; Return the greatest of the nums
;
; (min x)
; (min x y)
; (min x y & more)
;
[assume max (lambda nums
    (if (> (count nums) 1)
        (reduce (lambda (a b) (if (> a b) a b)) nums)
        (first nums)))]


; ## Map
;
; Map a function onto a list, or onto multiple lists
;
; (map f coll)
; (map f c1 c2)
; (map f c1 c2 c3)
; (map f c1 c2 c3 & colls)
;
[assume map (lambda args
    (begin
        (define func (first args))
        (define arglist (rest args))
        (define M (count arglist)) ; number of collections
        (if (= M 1)
            ; special case for single-argument functions
            (begin
                (define list-expr (first arglist))
                (if (= (count list-expr) 0)
                    (list)
                    (cons (func (first list-expr)) (map func (rest list-expr)))))
            ; multiple arguments
            (begin
                (define min-count (reduce (lambda (a b) (min (count a) (count b))) arglist))
                (if (= min-count 0)
                    (list)
                    (begin
                        (define new-args (map rest arglist))
                        (cons 
                            (apply func (map first arglist)) 
                            (apply map (cons func new-args)))))))))]


; ## Filter
;
; Remove elements that fail to pass a (boolean) test predicate
;
; (filter pred list-expr)
;
[assume filter (lambda (pred list-expr)
    (if (= (count list-expr) 0)
        (list)
        (if (pred (first list-expr))
            (cons (first list-expr) (filter pred (rest list-expr)))
            (filter pred (rest list-expr)))))]


; ## Repeat
;
; Generate a list of N identical elements
;
; (repeat N expr)
;
[assume repeat (lambda (N expr)
    (if (= N 0)
        (list)
        (cons expr (repeat (- N 1) expr))))]


; ## Repeatedly
;
; Generate a list of N entries, each generated by a call to a function with no args
;
; (repeatedly N func)
;
[assume repeatedly (lambda (N func)
    (if (= N 0)
        (list)
        (cons (func) (repeatedly (- N 1) func))))]


; ## Range
;
; Get a list of integers in a given range, inclusive.
;
; (range end)
; (range start end)
; (range start end step)
;
; `start` defaults to 0, and `step` defaults to 1.
;
[assume range (lambda args
    (begin
        (define N (count args))
        (define start (if (> N 1) (first args) 0))
        (define end (if (> N 1) (second args) (first args)))
        (define step (if (> N 2) (second (rest args)) 1))        
        (if (> start end)
            (list)
            (cons start (range (+ start step) end step)))))]

; ## Dot Product
;
; Vector-vector dot product
;
; (dot-product u v)
;
[assume dot-product (lambda (u v) 
    (if (= (count u) 0) 
        0 
        (+ (* (first u) (first v)) (dot-product (rest u) (rest v)))))]
